# 8장 인덱스

- 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다
- 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이다.
- 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.

## 인덱스란

- 책의 맨 끝에 있는 찾아보기로 설명된다
- 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스로 만든다
- 책의 찾아보기와 DBMS 인덱스의 가장 중요한 공통점은 정렬이다
- SortedList의 장단점 처럼 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬되어 있어서 원하는 값을 빨리 찾을 수 있다.
- 인덱스가 많으면 UPDATE, DELETE 문자의 처리가 느려진다
- SELECT 문장은 빠르게 처리할 수 있다

## B-Tree 인덱스

- B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다
- 구조 및 특성
    - 최상위에 하나의 노드 → 루트노드
    - 가장 하위에 있는 노드 → 리프 노드
    - 중간 노드 → 브렌치 노드
    - 데이터베이서에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리하는데
    - 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
    
    ![Untitled](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20489511eaf19d48139a3e12a1c4a1c530/Untitled.png)
    
    ![Untitled](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20489511eaf19d48139a3e12a1c4a1c530/Untitled%201.png)
    
    - InnoDB 스토리지 엔진에서는 프라이머리 키가 ROWID 역할을 한다
    - 세컨더리 인덱스에서 InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다
    - 그래서 데이터 파일을 바로 찾아가지 못하고, 인덱스에 저장돼 있는 프라이머리 키 값을 이용해서 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼있는 레코드를 읽는다.
    - InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야한다.
    
    ### B-Tree 인덱스 키 추가 및 삭제
    
    - 테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작입이 발생한다
    - 인덱스 키 추가
        - InnoDB 스토리지 엔진은 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다.
        - 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다
    - 인덱스 키 삭제
        - 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면된다.
        - 마크된 공간은 방치하거나 재활용 가능
        - 마킹 작업 또한 디스크 쓰기가 필요하다
    - 인덱스 키 변경
        - 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 단순히 인덱스 상의 키 값만 변경하는 것은 불가능하다
        - 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리한다
    - 인덱스 키 검색
        - INSERT, UPDATE, DELETE 할 때 인덱스의 추가비용을 감당하는 이유는 빠른 검색을 위한 것
        - 트리 탐색은 SELECT만이 아니라 UPDATE, DELETE 처리하기 위해 항상 해당 레코드를 먼저 검색할 경우에도 사용된다
    
    ### B-Tree 인덱스 사용에 영향을 미치는 요소
    
    - 인덱스 키 값의 크기
        - 데이터를 저장하는 기본 단위는 페이지
        - 인덱스도 페이지로 관리되며, 루트와 브랜치, 그리고 리프 노드를 구분한 기준이 페이지
        - 인덱스 키 값의 크기가 커지면 한 페이지에 들어가는 데이터의 수가 줄어들기 때문에 트리의 더 많은 depth를 탈 수 있어서, 성능에 영향을 준다
        - 인덱스 키 값이 길어지면 버퍼 풀에 캐시할 수 있는 영역이 줄어든다.
    - 선택도
        - 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
        - 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
    
    ### B-Tree 인덱스를 통한 데이터 읽기
    
    - 인덱스 레인지 스캔
        - 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
        - 레코드의 시작점을 찾고 그때부터는 리프 노드의 레코드만 순서대로 읽는다
        - 리프 노드의 끈까지 읽으면 리프 노드 간의 링크를 이용해 다름 리프 노드를 찾아 다시 스캔한다
        
        ![Untitled](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20489511eaf19d48139a3e12a1c4a1c530/Untitled%202.png)
        
    
    - 인덱스 풀 스캔
        - 인덱스의 처음부터 끈까지 모두 읽는 방식
        - 조건절에 사용된 컬럼이 인덱스의 첫 번째 칼럼이 아닌 경우
        - 인덱스 내부의 데이터만 전부 읽을 경우, 인덱스 전체의 크기는 데이블 자체의 크기보다 작으므로 인덱스 풀 스캔이 테이블 전체를 읽는 것보다 빠르다
        - 인덱스 외부의 값, 레코드를 타고 다시 조회해야하면 훨씬 느리다
    - 루스 인덱스 스캔
        - 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어간다
        - GROUP BY 또는 집합 함수 가운데 MAX, MIN 함수에 대해 최적화 할 때 사용한다
    - 인덱스 스킵 스캔
        - A, B 순서대로 인덱스를 구성하였을 때, B조건으로만 검색하면 인덱스를 효율적으로 사용할 수 없다.
        - 그래서 A값의 유니크한 값을 기준으로 다시 검색한다
        - where B > 20 → where A = 1 and B > 20, where A = 2 and B > 20 (A의 유니크 한 값 기준두개의 select 문으로 분리된다)
        - 선행 컬럼의 유니크한 갯수가 적어야 하고, 커버링 인덱스여만 하는 단점이 있다