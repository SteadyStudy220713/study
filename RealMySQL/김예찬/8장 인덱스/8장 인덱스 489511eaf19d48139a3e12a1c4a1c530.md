# 8장 인덱스

- 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다
- 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이다.
- 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.

## 인덱스란

- 책의 맨 끝에 있는 찾아보기로 설명된다
- 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스로 만든다
- 책의 찾아보기와 DBMS 인덱스의 가장 중요한 공통점은 정렬이다
- SortedList의 장단점 처럼 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬되어 있어서 원하는 값을 빨리 찾을 수 있다.
- 인덱스가 많으면 UPDATE, DELETE 문자의 처리가 느려진다
- SELECT 문장은 빠르게 처리할 수 있다

## B-Tree 인덱스

- B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다
- 구조 및 특성
    - 최상위에 하나의 노드 → 루트노드
    - 가장 하위에 있는 노드 → 리프 노드
    - 중간 노드 → 브렌치 노드
    - 데이터베이서에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리하는데
    - 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
    
    ![Untitled](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20489511eaf19d48139a3e12a1c4a1c530/Untitled.png)
    
    ![Untitled](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20489511eaf19d48139a3e12a1c4a1c530/Untitled%201.png)
    
    - InnoDB 스토리지 엔진에서는 프라이머리 키가 ROWID 역할을 한다
    - 세컨더리 인덱스에서 InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다
    - 그래서 데이터 파일을 바로 찾아가지 못하고, 인덱스에 저장돼 있는 프라이머리 키 값을 이용해서 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼있는 레코드를 읽는다.
    - InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야한다.
    
    ### B-Tree 인덱스 키 추가 및 삭제
    
    - 테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작입이 발생한다
    - 인덱스 키 추가
        - InnoDB 스토리지 엔진은 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다.
        - 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다
    - 인덱스 키 삭제
        - 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면된다.
        - 마크된 공간은 방치하거나 재활용 가능
        - 마킹 작업 또한 디스크 쓰기가 필요하다
    - 인덱스 키 변경
        - 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 단순히 인덱스 상의 키 값만 변경하는 것은 불가능하다
        - 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리한다
    - 인덱스 키 검색
        - INSERT, UPDATE, DELETE 할 때 인덱스의 추가비용을 감당하는 이유는 빠른 검색을 위한 것
        - 트리 탐색은 SELECT만이 아니라 UPDATE, DELETE 처리하기 위해 항상 해당 레코드를 먼저 검색할 경우에도 사용된다
    
    ### B-Tree 인덱스 사용에 영향을 미치는 요소
    
    - 인덱스 키 값의 크기
        - 데이터를 저장하는 기본 단위는 페이지
        - 인덱스도 페이지로 관리되며, 루트와 브랜치, 그리고 리프 노드를 구분한 기준이 페이지
        - 인덱스 키 값의 크기가 커지면 한 페이지에 들어가는 데이터의 수가 줄어들기 때문에 트리의 더 많은 depth를 탈 수 있어서, 성능에 영향을 준다
        - 인덱스 키 값이 길어지면 버퍼 풀에 캐시할 수 있는 영역이 줄어든다.
    - 선택도
        - 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
        - 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
    
    ### B-Tree 인덱스를 통한 데이터 읽기
    
    - 인덱스 레인지 스캔
        - 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
        - 레코드의 시작점을 찾고 그때부터는 리프 노드의 레코드만 순서대로 읽는다
        - 리프 노드의 끈까지 읽으면 리프 노드 간의 링크를 이용해 다름 리프 노드를 찾아 다시 스캔한다
        
        ![Untitled](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20489511eaf19d48139a3e12a1c4a1c530/Untitled%202.png)
        
    
    - 인덱스 풀 스캔
        - 인덱스의 처음부터 끈까지 모두 읽는 방식
        - 조건절에 사용된 컬럼이 인덱스의 첫 번째 칼럼이 아닌 경우
        - 인덱스 내부의 데이터만 전부 읽을 경우, 인덱스 전체의 크기는 데이블 자체의 크기보다 작으므로 인덱스 풀 스캔이 테이블 전체를 읽는 것보다 빠르다
        - 인덱스 외부의 값, 레코드를 타고 다시 조회해야하면 훨씬 느리다
    - 루스 인덱스 스캔
        - 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어간다
        - GROUP BY 또는 집합 함수 가운데 MAX, MIN 함수에 대해 최적화 할 때 사용한다
    - 인덱스 스킵 스캔
        - A, B 순서대로 인덱스를 구성하였을 때, B조건으로만 검색하면 인덱스를 효율적으로 사용할 수 없다.
        - 그래서 A값의 유니크한 값을 기준으로 다시 검색한다
        - where B > 20 → where A = 1 and B > 20, where A = 2 and B > 20 (A의 유니크 한 값 기준두개의 select 문으로 분리된다)
        - 선행 컬럼의 유니크한 갯수가 적어야 하고, 커버링 인덱스여만 하는 단점이 있다

### 다중 컬럼 인덱스

- 두 개 이상의 컬럼으로 구성된 인덱스를 다중 컬럼 인덱스라고 한다.
- 인덱스의 두 번째 컬럼은 첫 번째 칼럼에 의존해서 정렬돼 있다.
- 즉 두 번째 칼럼의 정렬은 첫 번째 칼럼이 똑같은 레코드에서만 의미가 있다.

### B-Tree 인덱스의 정렬 및 스캔 방향

- 8.0부터는 정렬 순서를 혼합한 인덱스도 생성할 수 있게 됐다
- 정순 인덱스 스캔이 빠르다
    - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
    - 인덱스 레코드가 단방향으로 연결된 구조

### B-Tree 인덱스의 가용성과 효율성

- 비교 조건의 종류와 효율성
    - 인덱스의 N번째 키 값은 N - 1번째 키 값에 대해서 다시 정렬되기 때문이 이러한 상황이 발생한다.
    
    ```jsx
    SELECT * FROM depth_emp
    WHERE dept_no = 'd002' AND emp_no >= 10114;
    
    케이스 A: INDEX(dept_no, emp_no)
    케이스 B: INDEX(emp_no, dept_no)
    ```
    
    ![Untitled](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20489511eaf19d48139a3e12a1c4a1c530/Untitled%203.png)
    
    - 케이스 A 인덱스에서는 두 조건 모두 작업 범위를 결정하고
    - 케이스 B 인덱스에서는 emp_no 만 작업 범위를 결정한다
- 인덱스의 가용성
    - 하나의 컬럼으로 검색해도 값의 왼쪽 부분이 없으면 인덱스 레인지 스캔 방식의 검색 불가능
    - 다중 컬럼 인덱스에서도 왼쪽 칼럼 값을 모르면 인덱스 레인지 스캔을 사용할 수 없음
- 가용성과 효율성 판단
    - 인덱스가 작업 범위를 결정하는데 사용할 수 없는 경우
        - NOT-EQUAL
        - LIKE %??
        - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우
        - 데이터 타입이 서로 다른 비교(타입 변환 후 비교 가능)
        - 문자열 데이터 타입의 콜레이션이 다른 경우

## 멀티 밸류 인덱스

- Json 포맷으로 데이터를 저장하는 경우
- 멀티 밸류 인덱스를 활용하기 위해서는 일반적인 조건 방식을 사용하면 X
- 받드시 다음 함수들을 이용해서 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립한다
    - MEMBER OF()
    - JSON_CONTAINS()
    - JSON_OBERLAPS()

## 클러스터링 인덱스

- 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현한다.
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다는 것이다.
- 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 결정된다는 것이다.
    
    ![Untitled](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20489511eaf19d48139a3e12a1c4a1c530/Untitled%204.png)
    

### 세컨더리 인덱스에 미치는 영향

- 세컨더리 인덱스를 검색해 레코드의 프라이머리 키 값을 확인한 후
- 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져옴

### 클러스터링 인덱스의 장점과 단점

- 장점
    - 프라이머리 키로 검색할 때 처리 성능이 매우 빠름
    - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에
        
        인덱스로만 처리될 수 있는 경우가 많음
        
- 단점
    - 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
    - insert 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
    - 프라이머리 키를 변경할 때 레코드를 delete, insert 하는 작업 때문에 느림

## 유니크 인덱스

- 유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스는 사실 인덱스의 구조상 아무런 차이점이 없다.

### 인덱스 읽기

- 세컨더리 인덱스와 속도면에서 차이가 없다
    - 유니크 인덱스는 한 건을 읽게 되기 때문에 빠른 것이다
    - 세컨더리 인덱스가 읽게되는 건 수 2개에 0.2초, 유니크 인덱스로 읽게 되는 건 수 1개에 0.1 초
    - 평균치는 동일하다

### 인덱스 쓰기

- 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다
- 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기 할 때는 쓰기 잠금을 사용해
    
    데드락이 빈번히 발생한다
    
- 유니크 인덱스는 중복 체크를 해야 하므로 체인지 버퍼를 사용해 버퍼링하지 못한다.

## 외래키

- 테이블의 변경이 발생하는 경우에만 잠금 경합이 발생한다
- 외래키와 연관되지 않은 칼럼의 벼경은 최대한 잠금 경합을 발생시키지 않는다
- 자식 테이블의 변경이 대기하는 경우
    
    ![Untitled](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20489511eaf19d48139a3e12a1c4a1c530/Untitled%205.png)
    
- 부모 테이블의 변경 작업이 대기하는 경우
    
    ![Untitled](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20489511eaf19d48139a3e12a1c4a1c530/Untitled%206.png)