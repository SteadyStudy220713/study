# 5장 트랜잭션

- 트랜젝션
    - 논리적인 작업 셋을 모두 완벽하게 처리하거나
        
        처리하지 못할 경우에는 원 상대로 복구한다
        
    - 작업의 완전성을 보장
    - 데이터의 정합성을 보장
- 잠금
    - 여러 커넥션에서 동시에 동일한 자원을 요청할 경우
        
        순서대로 한 시점에 하나의 커넥션만 변경할 수 있게해준다
        
    - 동시성을 제어하기 위한 기능

## 잠금

- MySQL 엔진 레벨 잠금 : 잠금이 모든 스토리지 엔진에 영향을 준다
- 스토리지 엔진 레벨 잠금 : 스토리지 엔진 간 상호 영향을 미치지 않는다

### MySQL 엔진의 잠금

1. 글로벌 락
    - 한 세션에서 글로벌 락을 획득하면 다른 세션에서 select 제외한 대부분의 DDL, DML 문장이 락 걸린다
    - 영향을 미치는 범위는 MySQL 서버 전체
2. 테이블 락
    - 개별 테이블 단위로 설정되는 잠금
    - InnoDB에서는 스키마를 변경하는 DDL의 경우에만
3. 네임드 락
    - 여러 대의 웹 서비스가 상호 동기화를 처리해야할 때 사용
    - 배치 프로그램에서 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서
        
        네임드 락을 걸고 쿼리를 실행하면 간단히 해결 가능하다
        
4. 메타데이터 락
    - 데이터베이스 객체(테이블 or 뷰)의 이름이나 구조를 변경하는 경우 획득하는 잠금

### InnoDB 스토리지 엔진 잠금

- 레코드 기반의 잠금 방식
- 잠금 종류
    1. 레코드 락
        - 레코드 자체만을 잠그는 것
        - 레코드 자체가 아니라 인덱스의 레코드를 잠근다
        - 인덱스가 하나도 없는 테이블이라도, 자동으로 생선된 클러스터 인덱스를 이용해 잠금을 설정
    2. 갭 락
        - 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만 잠그는 것
        - 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어
    3. 넥스트 키 락
        - 레코드 락 + 갭 락
        - 바이너르 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
        - 데드락이 발생할 수 있기 때문에 바이너리 로그 포맷을 ROW 형태로 바꾸어 넥스트 키 락이나 갭 락을 줄이는 것이 좋다
    4. 자동 증가 락
        - AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야한다
        - 이를 위해 InnoDB 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용한다.
        - INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간 락이 걸렸다가 즉시 해제된다.
        - AUTO_INCREMENT 락을 걸면 나머지 쿼리는 AUTO_INCREMENT 락을 기다려야 한다.
        - 잠금을 최소화하기 위해서 자동 증가 값이 한 번 증가하면 절대 줄어들지 않는다
- 인덱스와 잠금
    - InnoDB 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.
    - 변경해야 할 레코드를 찾끼 위해 검색한 인덳의 레코드를 모두 락 걸어야한다.
    - UPDATE 문장을 해서 적절한 인덱스가 준비돼 있지 않다면 각 클라이언트의 동시성은 상당히 떨어진다
    - 인덱스가 없다면 테이블을 풀 스캔하면서 모든 레코드를 잠그게 된다

### MySQL의 격리 수준

- 트랜잭션의 격리 수준이랑 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다
- 격리 수준 종류
    1. READ UNCOMMITTED
        - 다른 트랜잭션의 커밋되지 않는 이력을 조회할 수 있다 → DIRTY READ 발생
        - 더티 리드 현상은 데이터가 나타났다가 사라졌다 하는 현상을 초래하므로 사용자를 혼란스럽게 만든다.
    2. READ COMMITTED
        - 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜젝션에서 조회할 수 있다.
        - 언두 영역에 백업된 레코드를 가져온다
        - 하나의 트랜잭션 내에서는 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 “REPEATABLE READ” 정합성에 어긋난다. → NON-REPEATABLE READ가 발생
    3. REPEATABLE READ
        - MVCC를 이용해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다
        - READ COMMITTEDD의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다
        - SELECT … FOR UPDATE 쿼리 결과가 다르다 (현재 레코드 기준으로 가져온다) → PHANTOM READ 발생
        - InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 PHANTOM READ 발생하지 않음
    4. SERIALIZABLE
        - SELECT 작업시에도 읽기 잠금을 획득해야 한다
        - 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근할 수 없다