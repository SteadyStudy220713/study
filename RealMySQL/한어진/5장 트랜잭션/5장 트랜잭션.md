#

# 트랜잭션

트랜잭션은 작업의 완전성을 보장해준다. (Atomic !)

- 모두 완벽하게 처리(`Commit`) or 처리하지 못한다면 원 상태로 복구(`Rollback`)
- 작업의 일부만 적용되는 `Partial update` 현상을 방지함.

```tsx
try{
	START TRANSACTION;
	블라블라
	블라블라
	...
	COMMIT;
} catch(exception) {
	ROLLBACK;
}
```

트랜잭션은 **꼭 필요한 최소의 코드에만 적용**하는 것이 좋다.

DBMS에 직접적인 영향을 주는 부분에만 트랜잭션을 걸도록 하자.

- 일반적으로 데이터베이스 커넥션 개수가 제한적이므로, 불필요하게 커넥션을 들고 있으면 낭비다.

<aside>
💡 특히 **네트워크 작업** 등 원격 서버와 통신하는 부분들 어떻게 해서든 트랜잭션에서 빼자!

</aside>

## 예시

![트랜잭션 개선 예시](./%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20%EA%B0%9C%EC%84%A0%20%EC%98%88%EC%8B%9C.png)

---

# 락(Lock)

## 글로벌 락

> 글로벌 락 명령 : `FLUSH TABLES WITH READ LOCK`

- MySQL에서 제공하는 잠금 중 가장 범위가 크다
- 한 세션에서 글로벌 락 획득 시, 다른 세션에서는 `SELECT`를 제외한 **대부분의 DDL, DML 문장**은 글로벌 락이 풀릴 때 까지 **대기 상태**로 남는다.
- 영향 범위는 MySQL 서버 전체. ( 작업 대상 테이블이나 데이터베이스가 다르더라도 영향을 미침 )
  - 실행과 동시에 서버에 존재하는 모든 테이블을 닫고 잠금을 건다.
- 잠금을 걸기 전에 먼저 테이블을 플러시 해야하므로, 먼저 실행 중인 모든 종류의 쿼리가 완료된 후에 실행된다.

<aside>
💡 글로벌 락은 서버의 모든 테이블에 영향을 미치므로, 웹 서비스용으로 사용되고 있다면 가급적 사용하지 않는 것이 좋다.
( 장시간 실행되는 쿼리와 글로벌 락 명령이 엮이면 장시간 동안 묶여있을 수도 있으므로 )
</aside>

## 백업 락

- 조금 더 가벼운 글로벅 락
- InnoDB 스토리지 엔진은 트랜잭션을 지원하므로, 모든 데이터 변경 작업을 멈출 필요는 없음.
- MySQL 8.0 버전부터는 Xtrabckup이나 Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입되었음.
- 특정 세션에서 백업 락을 획득하면, 모든 세션에서 다음과 같은 **테이블의 스키마나 사용자의 인정 관련 정보를 변경할 수 없게 된다.**
  - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
  - `REPAIR TABLE`과 `OPTIMIZE TABLE` 명령
  - 사용자 관리 및 비밀번호 변경

<aside>
💡 일반적인 테이블의 데이터 변경은 허용됨.

</aside>

6~7시간 동안 백업이 진행 중인데 DDL 명령 하나로 인해 백업이 실패하게 된다. 이런 상황을 방지하고자 백업 락이 도입 되었음.

정상적으로 복제는 실행되지만, 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시 중지하는 역할을 한다.

## 테이블 락

> 명시적으로 테이블 락 걸기 : `LOCK TABLES table_name [ READ | WRITE ]`

> 명시적으로 얻은 테이블 락 해제(반납) : `UNLOCK TABLES`

- 개별 테이블 단위로 설정되는 잠금이다.
- `명시적 잠금`과 `묵시적 잠금`이 있다.
  - **명시적인 테이블 락**도 특별한 상황이 아니면 **사용할 필요가 거의 없다**. (온라인 작업에 상당한 영향을 미치기 때문)
  - 묵시적 락은 **테이블에 데이터를 변경하는 쿼리**를 실행하면 자동으로 발생함.
    - 잠금 → 데이터 변경 → 잠금해제

`InnoDB`은 **레코드 기반 잠금**을 제공함

테이블 락을 하긴 하지만 **DML 쿼리에서는 무시**되고, **DDL의 경우에만 영향**을 미침

## 네임드 락

> 네임드 락 획득 명령 : `GET_LOCK()`

- 임의의 문자열에 대해 잠금 설정
  - 단순히 **사용자가 지정한 문자열에 대해** 획득하고 반납하는 잠금

@@네임드 락을 얻지 못하면 작업을 하지 않는다! 이렇게 정해놓고 쓰는 것임.

```tsx
// 'mylock' 문자열에 대해 락 설정
mysql> SELECT GET_LOCK('mylock', 10)

// 'mylock' 문자열에 대한 네임드 락 상태 확인
mysql> SELECT IS_FREE_LOCK('mylock')

// 'mylock' 문자열에 대한 네임드 락 반납
mysql> SELECT RELEASE_LOCK('mylock')
```

## 메타데이터 락

- 데이터베이스 객체(테이블 or 뷰 등)의 이름이나 구조를 변경하는 경우에 자동으로 획득
- 명시적으로 획득하지 않음

```tsx
// 이 경우에는 메타데이터 락으로 인해 rank를 못읽는 경우는 발생하지 않는다.
// ( 락을 걸고 락이 풀리기 전까진 읽기를 막으므로 )
mysql> RENAME TABLE rank To rank_backup, rank_new To rank;

// 이 경우에는 두 작업 사이에 요청이 올 경우에는 **Table not found rank** 오류가 발생한다.
// ( 짧은 시간이지만 rank 테이블이 존재하지 않고 노출되는 순간이 생기므로 )
mysql> RENAME TABLE rank To rank_backup;
mysql> RENAME TABLE rank_new To rank;
```
